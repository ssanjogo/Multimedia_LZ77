{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs for Multimedia_LZ77","text":""},{"location":"#description","title":"Description","text":"<p>The idea of this code is to do a LZ77 codification. </p> <p>In the following text we are going to explain how the algorithm will work. Binary string with: - Header with the first \"Mdes\" bits of the input data - From this header, the control bit must be inserted.     - \"0\" for literals.     - \"1\" for tuples (L,D) - Store matches of L = 1 as literals. - Store matches (with L &gt; 1) as tuples (L, D) encoded in fixed-length binary format (log2(Ment) + log2(Mdes) bits in total) - The search for matches ends when the remaining bits to be processed are fewer than Ment. In such case, store these remaining bits at the end of the compressed string.</p>"},{"location":"#input-and-output-data","title":"Input and output data","text":"<ul> <li>Input and output data format will be a binary string (ones and zeros) of arbitrary length.</li> <li>We will have the possibility to configure variable Input Window Length (Ment) and Sliding Window Length (Mdes). For a valid configuration control, Ment and Mdes must be:</li> <li>powers of 2</li> <li>Ment &lt;= Mdes</li> <li>Mdes + Ment &lt;= length of data to be compressed</li> </ul>"},{"location":"#execution-of-the-code","title":"Execution of the code","text":"<p>First you have to install the requirements.txt located in the main directory using this code: </p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>To run the code you have to go to the folder that contains the main.py, in this case the address of this folder is: MULTIMEDIA_LZ77/src/ and in this directory we will find the main.py The next step is to execute the main.py file using the command:</p> <pre><code>python main.py\n</code></pre> <p>*Maybe you have to use python3 instead of python. </p>"},{"location":"#execution-of-the-documentation","title":"Execution of the documentation","text":"<p>To run the documentation using mk you must do the following, from the root folder:</p> <p>Important: you must install the requirements first.</p> <pre><code>mkdocs build\n\n\nmkdocs serve\n</code></pre> <p>When you run the serve, you will get the web page address on the command line, so you have to open it on your browser. </p>"},{"location":"LZ77/","title":"LZ77 Functions","text":"<p>On this page you will find the methods used to code LZ77.</p>"},{"location":"LZ77/#src.LZ77Functions.LZ77Functions.analisis","title":"<code>analisis(text, Mdes, Ment)</code>","text":"<p>Method to give the information for the analysis of the data </p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Name of the file that contains the data to be analized.</p> required <code>Ment</code> <code>int</code> <p>Number of bits for entropy coding.</p> required <code>Mdes</code> <code>int</code> <p>Number of bits for describing the data.</p> required <p>Returns:</p> Source code in <code>src/LZ77Functions/LZ77Functions.py</code> <pre><code>def analisis(text, Mdes, Ment):\n    '''\n    Method to give the information for the analysis of the data \n\n    Args:\n        file_name (str): Name of the file that contains the data to be analized.\n        Ment (int): Number of bits for entropy coding.\n        Mdes (int): Number of bits for describing the data.\n\n    Returns:\n\n\n    '''\n    #con distintos valores de Mdes y Ment entre 4 y 4096 y analizad el factor de compresi\u00f3n y el tiempo invertido\n    compression_ratio = 0\n    if Mdes &lt; Ment:\n        return \"error\"\n\n    inicio = time.time()\n\n    if text:\n        binario = texto_a_ascii(text)\n        compressed_data = lz77_compress(binario, Ment, Mdes)\n        compression_ratio = len(text) / len(compressed_data)\n\n    fin = time.time()  # Tiempo de finalizaci\u00f3n\n    tiempo_total = fin - inicio\n    return {'tiempo':tiempo_total, \"Ratio Compression\":compression_ratio, \"Factor\": str(compression_ratio)+\":1\"}\n</code></pre>"},{"location":"LZ77/#src.LZ77Functions.LZ77Functions.ascii_binario_a_texto","title":"<code>ascii_binario_a_texto(ascii_binario)</code>","text":"<p>Convert binary ASCII representation to text.</p> <p>Parameters:</p> Name Type Description Default <code>ascii_binario</code> <code>str</code> <p>Binary ASCII representation to be converted to text.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Text decoded from the binary ASCII representation.</p> Source code in <code>src/LZ77Functions/LZ77Functions.py</code> <pre><code>def ascii_binario_a_texto(ascii_binario):\n    '''\n    Convert binary ASCII representation to text.\n\n    Args:\n        ascii_binario (str): Binary ASCII representation to be converted to text.\n\n    Returns:\n        str: Text decoded from the binary ASCII representation.\n\n    '''\n    text = \"\"                                                           # Initialize the string where we are going to write the ASCII.\n\n    for i in range(0, len(ascii_binario), 8):                           # We iterate throug the binary ASCII, 8 bits each one.\n        byte = ascii_binario[i:i+8]                                     # We take 8 bits together. \n        decimal = int(byte, 2)                                          # Convert from binary to decimal.\n        caracter = chr(decimal)                                         # Convert from decimal to a ASCII character. \n        text += caracter                                                # Add the character to the output string. \n\n    return text                                                         # Give back the string text. \n</code></pre>"},{"location":"LZ77/#src.LZ77Functions.LZ77Functions.lz77_compress","title":"<code>lz77_compress(data, Ment, Mdes)</code>","text":"<p>This method is used to compress some data with the lz77 algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>data(string)</code> <p>The information that we want to compress.</p> required <code>Ment(int)</code> <p>The input window.</p> required <code>Mdes(int)</code> <p>The sliding window.</p> required <p>Returns:   compressed_data: Output of the data compressed.</p> Source code in <code>src/LZ77Functions/LZ77Functions.py</code> <pre><code>def lz77_compress(data, Ment, Mdes):\n    '''\n    This method is used to compress some data with the lz77 algorithm.\n\n    Args:\n      data(string): The information that we want to compress.\n      Ment(int): The input window.\n      Mdes(int): The sliding window.\n    Returns:\n      compressed_data: Output of the data compressed.\n    '''\n\n    validate_configuration(Ment, Mdes, len(data))                                                       # Check if the configuration is valid. \n    compressed_data = str(data[0:Mdes])                                                                 # Inicialize the compressed data as the string of the sliding window.\n    i = Mdes                                                                                            # Inicialize i as the sliding window. \n    while i &lt; len(data):                                                                                # Iterate while the sliding window is smaller than the length of the data. \n        if (i &gt; len(data)-Ment):                                                                        # Check if the length of the data minus the sliding window is smaller than i.                 \n            compressed_data += str(data[i:len(data)])                                                   # We add the remaining data to the compressed data. \n            return compressed_data                                                                      # Give back the compressed data\n\n        match_found = False                                                                             # Inicialize the variable to find a match as False. \n\n        for j in range(min(Ment, len(data) - i),1,-1):                                                  # For j in range 1 to the size of the input or the maximum of the string... To know how many values we are comparing.\n            if j == 1:                                                                                  # Check if j is equal to 1. \n                return \"Literal\"                                                                        # If so, whe have a Literal. \n\n            for k in range(max(0, i - Mdes),max(0, i - Mdes)+Mdes):                                     # Iteration to find matches in the sliding window\n                if j &gt; i-k:                                                                             # Check if j is bigger than i - k.\n                    break                                                                               # If so, finish the current iteration. \n\n                if data[i:i+j] == data[k:k+j]:                                                          # Check if there is a match of the data in our sliding window.\n                    match_found = True                                                                  # We activate the boolean because we found a match. \n                    match_length = j                                                                    # We establish the length of the match. \n                    match_distance = i - k                                                              # We establish the match distance. \n                    compressed_data += '1'                                                              # Addition of a 1 to the compressed data  \n\n                    if match_length == Ment:                                                            # In case that the match length is equal to the input window.\n                        compressed_data += format(0, '0' + str(int(math.log2(Ment))) + 'b')             # We write the compressed data into the output\n\n                    else:                                                                               # If the match length is not equal to the input window size.\n                        compressed_data += format(match_length, '0' + str(int(math.log2(Ment))) + 'b')  # We write the compressed data, with the match length. \n\n                    if match_distance == Mdes:                                                          # If the match distances is equal to the sliding window. \n                        compressed_data +=format(0, '0' + str(int(math.log2(Mdes))) + 'b')              # Write compressed data with no match distance.\n\n                    else:                                                                               # If the match distance is not equal to the sliding window size.\n                        compressed_data +=format(match_distance, '0' + str(int(math.log2(Mdes))) + 'b') # Write compressed data with match distance.\n\n                    i += match_length                                                                   # We establish the begining of the sliding window.\n                    break\n\n            if match_found:                                                                             # In case that we found a match. \n                break                                                                                   # We finish the current iteration. \n\n        if not match_found:                                                                             # In case that we didn't find a match.\n            compressed_data += '0' + data[i]                                                            # Addition of a literal to the compressed data. \n            i += 1                                                                                      # Add 1 to the begining of the sliding window. \n        match_found = False                                                                             # Reset the value of the match found.\n\n    return compressed_data[:Mdes] + compressed_data[Mdes:]                                              # Give back the compressed data. \n</code></pre>"},{"location":"LZ77/#src.LZ77Functions.LZ77Functions.lz77_decompress","title":"<code>lz77_decompress(compressed_data, Ment, Mdes)</code>","text":"<p>Decompress data using the LZ77 algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>compressed_data</code> <code>str</code> <p>Compressed data to be decompressed.</p> required <code>Ment</code> <code>int</code> <p>Number of bits for entropy coding.</p> required <code>Mdes</code> <code>int</code> <p>Number of bits for describing the data.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Decompressed data.</p> Source code in <code>src/LZ77Functions/LZ77Functions.py</code> <pre><code>def lz77_decompress(compressed_data, Ment, Mdes): \n    '''\n    Decompress data using the LZ77 algorithm.\n\n    Args:\n        compressed_data (str): Compressed data to be decompressed.\n        Ment (int): Number of bits for entropy coding.\n        Mdes (int): Number of bits for describing the data.\n\n    Returns:\n        str: Decompressed data.\n\n    '''\n    decompressed_data = compressed_data[:Mdes]\n    i = Mdes\n\n    while i &lt; len(compressed_data)-Ment:\n        control_bit = compressed_data[i]\n\n        if control_bit == '0':  # Literal\n            decompressed_data += compressed_data[i+1]\n            i += 2\n\n        else:  # Tupla (L,D)\n            length_bits = compressed_data[i+1:i+1+int(math.log2(Ment))]\n            distance_bits = compressed_data[i+1+int(math.log2(Ment)):i+1+int(math.log2(Ment))+int(math.log2(Mdes))]\n            length = int(length_bits, 2)\n            distance = int(distance_bits, 2)\n\n            if length == 0:\n                length = Ment\n            if distance == 0:\n                distance = Mdes\n\n            tmp=decompressed_data\n\n            for j in range(length):\n                decompressed_data += str(tmp[-distance+j])\n\n            i += 1 + int(math.log2(Ment)) + int(math.log2(Mdes))\n\n    decompressed_data+=str(compressed_data[i:])\n\n    return decompressed_data\n</code></pre>"},{"location":"LZ77/#src.LZ77Functions.LZ77Functions.read_file","title":"<code>read_file(file_name)</code>","text":"<p>Read the contents of a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Name of the file to read.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Contents of the file.</p> Source code in <code>src/LZ77Functions/LZ77Functions.py</code> <pre><code>def read_file(file_name):\n    '''\n    Read the contents of a file.\n\n    Args:\n        file_name (str): Name of the file to read.\n\n    Returns:\n        str: Contents of the file.\n\n    '''\n    try:\n        with open(file_name, 'r', encoding='latin1') as archivo:                           # We open the file. \n            contenido = archivo.read()                                  # We read the file\n        return contenido                                                # Give back the content of the file.\n\n    except FileNotFoundError:                                           # In case that we don't find the file.\n        print(f\"No se encontr\u00f3 el archivo '{file_name}'\")               # We print the exception. \n        return None                                                     # And return none. \n</code></pre>"},{"location":"LZ77/#src.LZ77Functions.LZ77Functions.texto_a_ascii","title":"<code>texto_a_ascii(text)</code>","text":"<p>Convert text to ASCII representation.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to be converted to ASCII.</p> required <p>Returns:</p> Name Type Description <code>text</code> <code>str</code> <p>List of ASCII values representing the input text.</p> Source code in <code>src/LZ77Functions/LZ77Functions.py</code> <pre><code>def texto_a_ascii(text):\n    '''\n    Convert text to ASCII representation.\n\n    Args:\n        text (str): Text to be converted to ASCII.\n\n    Returns:\n        text (str): List of ASCII values representing the input text.\n\n    '''\n\n    ascii_binario = \"\"                                                  # Initialize the string where we are going to write the ASCII.\n\n    for caracter in text:                                               # We iterate trough the text character by character. \n        ascii_decimal = ord(caracter)                                   # Obtain the decimal ASCII value.\n        ascii_binario += format(ascii_decimal, '08b')                   # Convert to a 8 bit binary and add it to the binary ASCII text. \n\n    return ascii_binario                                                # Give back the string text. \n</code></pre>"},{"location":"LZ77/#src.LZ77Functions.LZ77Functions.validate_configuration","title":"<code>validate_configuration(Ment, Mdes, data_length)</code>","text":"<p>Validate the configuration parameters.</p> <p>Parameters:</p> Name Type Description Default <code>Ment</code> <code>int</code> <p>Number of bits for entropy coding.</p> required <code>Mdes</code> <code>int</code> <p>Number of bits for describing the data.</p> required <code>data_length</code> <code>int</code> <p>Length of the data to be encoded.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the configuration is invalid.</p> Source code in <code>src/LZ77Functions/LZ77Functions.py</code> <pre><code>def validate_configuration(Ment, Mdes, data_length):\n    \"\"\"\n    Validate the configuration parameters.\n\n    Args:\n        Ment (int): Number of bits for entropy coding.\n        Mdes (int): Number of bits for describing the data.\n        data_length (int): Length of the data to be encoded.\n\n    Raises:\n        ValueError: If the configuration is invalid.\n    \"\"\"\n\n    if not (Ment &amp; (Ment - 1) == 0 and Mdes &amp; (Mdes - 1) == 0):                                         # Check if the input window and the sliding window are powers of 2. \n        raise ValueError(\"Ment and Mdes must be powers of 2\")                                           # If so, raise an error. \n    if Ment &gt; Mdes:                                                                                     # Check if the input window is bigger than the sliding window.\n        raise ValueError(\"Ment must be less than or equal to Mdes\")                                     # If so, raise an error. \n    if Mdes + Ment &gt; data_length:                                                                       # Check if the sliding window  plus the input window is bigger than the length of the data.\n        raise ValueError(\"Mdes + Ment must be less than or equal to data length\")                       # If so, raise an error. \n</code></pre>"},{"location":"main/","title":"Main-Task","text":"<p>In the main class we implemented different methods in order to answer the tasks that we are asked on the exercice.</p>"},{"location":"main/#src.main.main","title":"<code>main()</code>","text":"<p>Comentario para ver si funciona.</p> Source code in <code>src/main.py</code> <pre><code>def main():\n    '''\n    Comentario para ver si funciona.\n    '''\n    file_name = \"../media/raw/hamlet_short.txt\"\n    file_name2 = \"../media/raw/quijote_short.txt\"\n\n    ejemploUso1()\n    ejemploUso2()\n    ejemploUso3()\n    outputHamlet = analisis(file_name)\n    outputQuijote = analisis(file_name2)\n    plot(\"(Hamlet)\", outputHamlet)\n</code></pre>"}]}