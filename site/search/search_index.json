{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs for Multimedia_LZ77","text":""},{"location":"#description","title":"Description","text":"<p>The idea of this code is to do a LZ77 codification. </p> <p>In the following text we are going to explain how the algorithm will work. Binary string with: - Header with the first \"Mdes\" bits of the input data - From this header, the control bit must be inserted.     - \"0\" for literals.     - \"1\" for tuples (L,D) - Store matches of L = 1 as literals. - Store matches (with L &gt; 1) as tuples (L, D) encoded in fixed-length binary format (log2(Ment) + log2(Mdes) bits in total) - The search for matches ends when the remaining bits to be processed are fewer than Ment. In such case, store these remaining bits at the end of the compressed string.</p>"},{"location":"#input-and-output-data","title":"Input and output data","text":"<ul> <li>Input and output data format will be a binary string (ones and zeros) of arbitrary length.</li> <li>We will have the possibility to configure variable Input Window Length (Ment) and Sliding Window Length (Mdes). For a valid configuration control, Ment and Mdes must be:</li> <li>powers of 2</li> <li>Ment &lt;= Mdes</li> <li>Mdes + Ment &lt;= length of data to be compressed</li> </ul>"},{"location":"#execution-of-the-code","title":"Execution of the code","text":"<p>First you have to install the requirements.txt located in the main directory using this code: </p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>To run the code you have to go to the folder that contains the main.py, in this case the address of this folder is: MULTIMEDIA_LZ77/src/ and in this directory we will find the main.py The next step is to execute the main.py file using the command:</p> <pre><code>python main.py\n</code></pre> <p>*Maybe you have to use python3 instead of python. </p>"},{"location":"#execution-of-the-documentation","title":"Execution of the documentation","text":"<p>To run the documentation using mk you must do the following, from the root folder:</p> <p>Important: you must install the requirements first.</p> <pre><code>mkdocs build\n\n\nmkdocs serve\n</code></pre> <p>When you run the serve, you will get the web page address on the command line, so you have to open it on your browser. </p>"},{"location":"LZ77/","title":"LZ77 Functions","text":"<p>On this page you will find the methods used to code LZ77.</p>"},{"location":"LZ77/#src.LZ77Functions.LZ77Functions.analisis","title":"<code>analisis(text, Mdes, Ment)</code>","text":"<p>Method to give the information for the analysis of the data </p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Data to be analized.</p> required <code>Ment</code> <code>int</code> <p>Number of bits for entropy coding.</p> required <code>Mdes</code> <code>int</code> <p>Number of bits for describing the data.</p> required <p>Returns:</p> Name Type Description <code>dictionary</code> <p>We give back a dictionary with the time necesary to do the compression, the ratio compression and the factor.</p> Source code in <code>src/LZ77Functions/LZ77Functions.py</code> <pre><code>def analisis(text, Mdes, Ment):\n    '''\n    Method to give the information for the analysis of the data \n\n    Args:\n        text (str): Data to be analized.\n        Ment (int): Number of bits for entropy coding.\n        Mdes (int): Number of bits for describing the data.\n\n    Returns:\n        dictionary: We give back a dictionary with the time necesary to do the compression, the ratio compression and the factor. \n\n    '''\n\n    compression_ratio = 0                                               # Initialize the compression factor.\n    if Mdes &lt; Ment:                                                     # Check if the sliding window is smaller than the input window.\n        return \"error\"                                                  # If so, return an error.\n\n    inicio = time.time()                                                # Establish the init time. \n\n    if text:                                                            # If the text is not none.\n        binario = texto_a_ascii(text)                                   # We convert the text to binary ascii.\n        compressed_data = lz77_compress(binario, Ment, Mdes)            # Compress the data in binary.\n        compression_ratio = len(text) / len(compressed_data)            # Calculate the compression ratio.\n\n    fin = time.time()                                                   # Establish the finishing time. \n    tiempo_total = fin - inicio                                         # Calculate the time needed for the execution. \n\n    return {'Time': tiempo_total, 'Compression Ratio': compression_ratio, \n            'Factor': str(compression_ratio)+\":1\", 'Text length': len(text), \n            'Compressed data length': len(compressed_data)}             # Return the time, compression ratio and the factor, the text length and the compressed data length. \n</code></pre>"},{"location":"LZ77/#src.LZ77Functions.LZ77Functions.ascii_binario_a_texto","title":"<code>ascii_binario_a_texto(ascii_binario)</code>","text":"<p>Convert binary ASCII representation to text.</p> <p>Parameters:</p> Name Type Description Default <code>ascii_binario</code> <code>str</code> <p>Binary ASCII representation to be converted to text.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Text decoded from the binary ASCII representation.</p> Source code in <code>src/LZ77Functions/LZ77Functions.py</code> <pre><code>def ascii_binario_a_texto(ascii_binario):\n    '''\n    Convert binary ASCII representation to text.\n\n    Args:\n        ascii_binario (str): Binary ASCII representation to be converted to text.\n\n    Returns:\n        str: Text decoded from the binary ASCII representation.\n\n    '''\n    text = \"\"                                                           # Initialize the string where we are going to write the ASCII.\n\n    for i in range(0, len(ascii_binario), 8):                           # We iterate throug the binary ASCII, 8 bits each one.\n        byte = ascii_binario[i:i+8]                                     # We take 8 bits together. \n        decimal = int(byte, 2)                                          # Convert from binary to decimal.\n        caracter = chr(decimal)                                         # Convert from decimal to a ASCII character. \n        text += caracter                                                # Add the character to the output string. \n\n    return text                                                         # Give back the string text. \n</code></pre>"},{"location":"LZ77/#src.LZ77Functions.LZ77Functions.lz77_compress","title":"<code>lz77_compress(data, Ment, Mdes)</code>","text":"<p>This method is used to compress some data with the lz77 algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>data(string)</code> <p>The information that we want to compress.</p> required <code>Ment(int)</code> <p>The input window.</p> required <code>Mdes(int)</code> <p>The sliding window.</p> required <p>Returns:</p> Name Type Description <code>compressed_data</code> <p>Output of the data compressed.</p> Source code in <code>src/LZ77Functions/LZ77Functions.py</code> <pre><code>def lz77_compress(data, Ment, Mdes):\n    '''\n    This method is used to compress some data with the lz77 algorithm.\n\n    Args:\n      data(string): The information that we want to compress.\n      Ment(int): The input window.\n      Mdes(int): The sliding window.\n\n    Returns:\n      compressed_data: Output of the data compressed.\n\n    '''\n\n    validate_configuration(Ment, Mdes, len(data))                                                       # Check if the configuration is valid. \n    compressed_data = str(data[0:Mdes])                                                                 # Inicialize the compressed data as the string of the sliding window.\n    i = Mdes                                                                                            # Inicialize i as the sliding window. \n    while i &lt; len(data):                                                                                # Iterate while the sliding window is smaller than the length of the data. \n        if (i &gt; len(data)-Ment):                                                                        # Check if the length of the data minus the sliding window is smaller than i.                 \n            compressed_data += str(data[i:len(data)])                                                   # We add the remaining data to the compressed data. \n            return compressed_data                                                                      # Give back the compressed data\n\n        match_found = False                                                                             # Inicialize the variable to find a match as False. \n\n        for j in range(min(Ment, len(data) - i),1,-1):                                                  # For j in range 1 to the size of the input or the maximum of the string... To know how many values we are comparing.\n            if j == 1:                                                                                  # Check if j is equal to 1. \n                return \"Literal\"                                                                        # If so, whe have a Literal. \n\n            for k in range(max(0, i - Mdes),max(0, i - Mdes)+Mdes):                                     # Iteration to find matches in the sliding window\n                if j &gt; i-k:                                                                             # Check if j is bigger than i - k.\n                    break                                                                               # If so, finish the current iteration. \n\n                if data[i:i+j] == data[k:k+j]:                                                          # Check if there is a match of the data in our sliding window.\n                    match_found = True                                                                  # We activate the boolean because we found a match. \n                    match_length = j                                                                    # We establish the length of the match. \n                    match_distance = i - k                                                              # We establish the match distance. \n                    compressed_data += '1'                                                              # Addition of a 1 to the compressed data  \n\n                    if match_length == Ment:                                                            # In case that the match length is equal to the input window.\n                        compressed_data += format(0, '0' + str(int(math.log2(Ment))) + 'b')             # We write the compressed data into the output\n\n                    else:                                                                               # If the match length is not equal to the input window size.\n                        compressed_data += format(match_length, '0' + str(int(math.log2(Ment))) + 'b')  # We write the compressed data, with the match length. \n\n                    if match_distance == Mdes:                                                          # If the match distances is equal to the sliding window. \n                        compressed_data +=format(0, '0' + str(int(math.log2(Mdes))) + 'b')              # Write compressed data with no match distance.\n\n                    else:                                                                               # If the match distance is not equal to the sliding window size.\n                        compressed_data +=format(match_distance, '0' + str(int(math.log2(Mdes))) + 'b') # Write compressed data with match distance.\n\n                    i += match_length                                                                   # We establish the begining of the sliding window.\n                    break\n\n            if match_found:                                                                             # In case that we found a match. \n                break                                                                                   # We finish the current iteration. \n\n        if not match_found:                                                                             # In case that we didn't find a match.\n            compressed_data += '0' + data[i]                                                            # Addition of a literal to the compressed data. \n            i += 1                                                                                      # Add 1 to the begining of the sliding window. \n        match_found = False                                                                             # Reset the value of the match found.\n\n    return compressed_data[:Mdes] + compressed_data[Mdes:]                                              # Give back the compressed data. \n</code></pre>"},{"location":"LZ77/#src.LZ77Functions.LZ77Functions.lz77_decompress","title":"<code>lz77_decompress(compressed_data, Ment, Mdes)</code>","text":"<p>Decompress data using the LZ77 algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>compressed_data</code> <code>str</code> <p>Compressed data to be decompressed.</p> required <code>Ment</code> <code>int</code> <p>Number of bits for entropy coding.</p> required <code>Mdes</code> <code>int</code> <p>Number of bits for describing the data.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Decompressed data.</p> Source code in <code>src/LZ77Functions/LZ77Functions.py</code> <pre><code>def lz77_decompress(compressed_data, Ment, Mdes): \n    '''\n    Decompress data using the LZ77 algorithm.\n\n    Args:\n        compressed_data (str): Compressed data to be decompressed.\n        Ment (int): Number of bits for entropy coding.\n        Mdes (int): Number of bits for describing the data.\n\n    Returns:\n        str: Decompressed data.\n\n    '''\n    decompressed_data = compressed_data[:Mdes]                                                                      # Inicialization of the decompressed data\n    i = Mdes                                                                                                        # Establish the value of i as the sliding window. \n\n    while i &lt; len(compressed_data)-Ment:                                                                            # Iterate through the sliding window while the length of the compressed data minus the input window is bigger than the sliding window. \n        control_bit = compressed_data[i]                                                                            # Take the first bit. We know that is a control bit.\n\n        if control_bit == '0':  # Literal                                                                           # If the control bit is a 0 \n            decompressed_data += compressed_data[i+1]                                                               # Add the value to th e decompressed data.\n            i += 2                                                                                                  # Iterate to the next value. \n\n        else:  # Tupla (L,D)                                                                                        # If it is not a control bit, then we have the tupli from L, length of the match, and D position of the start of the match.\n            length_bits = compressed_data[i+1:i+1+int(math.log2(Ment))]                                             # Get/read the length of the match.\n            distance_bits = compressed_data[i+1+int(math.log2(Ment)):i+1+int(math.log2(Ment))+int(math.log2(Mdes))] # Get/read the value of the position of the match. \n            length = int(length_bits, 2)                                                                            \n            distance = int(distance_bits, 2)\n\n            if length == 0:                                                                                         # If the length is equal to 0.\n                length = Ment                                                                                       # we set the length value as the input window. \n            if distance == 0:                                                                                       # If the ditance is equal to 0.\n                distance = Mdes                                                                                     # we set the length value as the input window.                                                                                \n\n            tmp = decompressed_data                                                                                 # Creation and inicialization of a temporal variable as the decompressed data.\n\n            for j in range(length):                                                                                 # Iterate through the range of the length\n                decompressed_data += str(tmp[-distance+j])                                                          # Add the decompressed data of the distance plus the value that we iterate. \n\n            i += 1 + int(math.log2(Ment)) + int(math.log2(Mdes))                                                    # Incrementation of the i value.\n\n    decompressed_data+=str(compressed_data[i:])\n\n    return decompressed_data\n</code></pre>"},{"location":"LZ77/#src.LZ77Functions.LZ77Functions.read_file","title":"<code>read_file(file_name)</code>","text":"<p>Read the contents of a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Name of the file to read.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Contents of the file.</p> Source code in <code>src/LZ77Functions/LZ77Functions.py</code> <pre><code>def read_file(file_name):\n    '''\n    Read the contents of a file.\n\n    Args:\n        file_name (str): Name of the file to read.\n\n    Returns:\n        str: Contents of the file.\n\n    '''\n    try:\n        with open(file_name, 'r', encoding='latin1') as archivo:        # We open the file. \n            contenido = archivo.read()                                  # We read the file\n        return contenido                                                # Give back the content of the file.\n\n    except FileNotFoundError:                                           # In case that we don't find the file.\n        print(f\"No se encontr\u00f3 el archivo '{file_name}'\")               # We print the exception. \n        return None                                                     # And return none. \n</code></pre>"},{"location":"LZ77/#src.LZ77Functions.LZ77Functions.texto_a_ascii","title":"<code>texto_a_ascii(text)</code>","text":"<p>Convert text to ASCII representation.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to be converted to ASCII.</p> required <p>Returns:</p> Name Type Description <code>text</code> <code>str</code> <p>List of ASCII values representing the input text.</p> Source code in <code>src/LZ77Functions/LZ77Functions.py</code> <pre><code>def texto_a_ascii(text):\n    '''\n    Convert text to ASCII representation.\n\n    Args:\n        text (str): Text to be converted to ASCII.\n\n    Returns:\n        text (str): List of ASCII values representing the input text.\n\n    '''\n\n    ascii_binario = \"\"                                                  # Initialize the string where we are going to write the ASCII.\n\n    for caracter in text:                                               # We iterate trough the text character by character. \n        ascii_decimal = ord(caracter)                                   # Obtain the decimal ASCII value.\n        ascii_binario += format(ascii_decimal, '08b')                   # Convert to a 8 bit binary and add it to the binary ASCII text. \n\n    return ascii_binario                                                # Give back the string text. \n</code></pre>"},{"location":"LZ77/#src.LZ77Functions.LZ77Functions.validate_configuration","title":"<code>validate_configuration(Ment, Mdes, data_length)</code>","text":"<p>Validate the configuration parameters.</p> <p>Parameters:</p> Name Type Description Default <code>Ment</code> <code>int</code> <p>Number of bits for entropy coding.</p> required <code>Mdes</code> <code>int</code> <p>Number of bits for describing the data.</p> required <code>data_length</code> <code>int</code> <p>Length of the data to be encoded.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the configuration is invalid.</p> Source code in <code>src/LZ77Functions/LZ77Functions.py</code> <pre><code>def validate_configuration(Ment, Mdes, data_length):\n    \"\"\"\n    Validate the configuration parameters.\n\n    Args:\n        Ment (int): Number of bits for entropy coding.\n        Mdes (int): Number of bits for describing the data.\n        data_length (int): Length of the data to be encoded.\n\n    Raises:\n        ValueError: If the configuration is invalid.\n    \"\"\"\n\n    if not (Ment &amp; (Ment - 1) == 0 and Mdes &amp; (Mdes - 1) == 0):                                         # Check if the input window and the sliding window are powers of 2. \n        raise ValueError(\"Ment and Mdes must be powers of 2\")                                           # If so, raise an error. \n    if Ment &gt; Mdes:                                                                                     # Check if the input window is bigger than the sliding window.\n        raise ValueError(\"Ment must be less than or equal to Mdes\")                                     # If so, raise an error. \n    if Mdes + Ment &gt; data_length:                                                                       # Check if the sliding window  plus the input window is bigger than the length of the data.\n        raise ValueError(\"Mdes + Ment must be less than or equal to data length\")                       # If so, raise an error. \n</code></pre>"},{"location":"main/","title":"Main-Task","text":"<p>In the main class we implemented different methods in order to answer the tasks that we are asked on the exercice.</p>"},{"location":"main/#src.main.analisis","title":"<code>analisis(data, power1, power2)</code>","text":"<p>Method to get the values of Mdes and Ment in a range of (4, 4096) and the value of the time and ratio  compression for those specific sliding and input window.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>string</code> <p>data to be compressed. </p> required <code>power1</code> <code>int</code> <p>Value of the start of the range.</p> required <code>power2</code> <code>int</code> <p>Value of the end of the range. </p> required <p>Returns:</p> Name Type Description <code>dictionary</code> <p>Gives back a list of tuples of tuple (Mdes, Ment) and a dictionary of the analisis with the    time necesary to do the compression, the ratio compression and the factor.</p> Source code in <code>src/main.py</code> <pre><code>def analisis(data, power1, power2):\n    '''\n    Method to get the values of Mdes and Ment in a range of (4, 4096) and the value of the time and ratio \n    compression for those specific sliding and input window.\n\n    Args:\n        data (string): data to be compressed. \n        power1 (int): Value of the start of the range.\n        power2 (int): Value of the end of the range. \n\n    Returns:\n        dictionary: Gives back a list of tuples of tuple (Mdes, Ment) and a dictionary of the analisis with the \n              time necesary to do the compression, the ratio compression and the factor. \n    '''\n\n    analisis_results = {}                                                                                   # Creation of the dictionary where we are going to save the values.\n\n    for i in range(power1, power2):                                                                         # Iterate in order to get the powers of two for Mdes\n        mdes = 2 ** i                                                                                       # Calculate the mdes, that is 2 up to a value i. \n\n        for j in range (power1, power2):                                                                    # Iterate in order to get the powers of two for Ment.\n            ment = 2 ** j                                                                                   # Calculate the ment, that is 2 up to a value j. \n\n            if ((mdes &gt;= ment) and (mdes + ment &lt;= len(data))):                                             # Check if the sliding window is bigger than the input window and the sum of the sliding and input window is smaller or equal to the length of the data.\n                analisis_results[(mdes, ment)] = lz77.analisis(data, mdes, ment)                            # We add to the dictionary the results obtained \n\n    return analisis_results                                                                                 # Return the list of results. \n</code></pre>"},{"location":"main/#src.main.convertDictIntoLists","title":"<code>convertDictIntoLists(analisisDict)</code>","text":"<p>Method to convert the dictionary to diferent lists. </p> <p>Parameters:</p> Name Type Description Default <code>analisisDict</code> <code>dictionary</code> <p>the values obtained in the analisis.</p> required Source code in <code>src/main.py</code> <pre><code>def convertDictIntoLists(analisisDict):\n    '''\n    Method to convert the dictionary to diferent lists. \n\n    Args:\n        analisisDict (dictionary): the values obtained in the analisis. \n    '''\n    keys, mdes_values, ment_values, times, compressionFactors, originalLength, compressedLength = [], [], [], [], [], [], []\n\n    for key, value in analisisDict.items():                                                                 # Iterate through the values that we obtained. \n        keys.append(key)\n        mdes_values.append(key[0])                                                                          # Add the value of the sliding window.\n        ment_values.append(key[1])                                                                          # Add the values of the input window.\n        times.append(value['Time'])                                                                         # Add the time.\n        compressionFactors.append(value['Compression Ratio'])                                               # Add the ratio compress. \n        originalLength.append(value['Text length'])\n        compressedLength.append(value['Compressed data length'])\n\n    return keys, mdes_values, ment_values, times, compressionFactors, originalLength, compressedLength\n</code></pre>"},{"location":"main/#src.main.firstExample","title":"<code>firstExample()</code>","text":"<p>Method to show the first example, with a established input (1111111100100111), and then we call the method to compress and decompress.  We have the slinding and input window set as:     - Ment = 4     - Mdes = 8</p> Source code in <code>src/main.py</code> <pre><code>def firstExample():\n    '''\n    Method to show the first example, with a established input (1111111100100111), and then we call the method to compress and decompress. \n    We have the slinding and input window set as:\n        - Ment = 4\n        - Mdes = 8\n    '''\n\n    print(\"FIRST EXAMPLE\")\n    random_data = \"1111111100100111\"                                                                        # Establish the value of the random data. \n\n    compressed_data = lz77.lz77_compress(random_data, 4, 8)                                                 # Compress the established data\n    decompressed_data = lz77.lz77_decompress(compressed_data, 4, 8)                                         # Decompress the data previously compressed.\n\n    assert random_data == decompressed_data                                                                 # Check if the initial random data is equal to the decompressed data.\n    print(\"Original data:\", random_data)                                                                    # Show the original data.\n    print(\"Compressed data:\", compressed_data)                                                              # Show the data compressed\n    print(\"Decompressed data:\", decompressed_data)                                                          # Show the decompressed data.\n    print(\"The original data and the decompressed data are equal:\", random_data == decompressed_data, \"\\n\") # Show if the compressed data and the original data are equal.\n</code></pre>"},{"location":"main/#src.main.main","title":"<code>main()</code>","text":"<p>Main method, from where we are going to call the examples and other functions to show the correct behaviour of the compressor LZ77.</p> Source code in <code>src/main.py</code> <pre><code>def main():\n    '''\n    Main method, from where we are going to call the examples and other functions to show the correct behaviour of the compressor LZ77.\n    '''\n\n    firstExample()\n    secondExample()\n\n    randomData = ''.join([str(random.randint(0, 1)) for _ in range(1000)])\n    outputRandomData = analisis(randomData, 1, 12)\n    plotLength(outputRandomData)\n    plotCompressionRatio(\"Random Data\", outputRandomData)\n    plotTimeAndCompression(\"Random Data\", outputRandomData)\n\n    hamletFile = \"../media/raw/hamlet_short.txt\"\n    hamletData = lz77.read_file(hamletFile)  \n    outputHamlet = analisis(hamletData, 2, 13)\n    plotTimeAndCompression(\"(Hamlet)\", outputHamlet)\n\n    quijoteFile = \"../media/raw/quijote_short.txt\"\n    quijoteData = lz77.read_file(quijoteFile)  \n    outputQuijote = analisis(quijoteData, 2, 13)\n    plotTimeAndCompression(\"(Quijote)\", outputQuijote)\n</code></pre>"},{"location":"main/#src.main.plotCompressionRatio","title":"<code>plotCompressionRatio(file_name, analisisDict)</code>","text":"<p>Method to plot the compression ratio and print on the screen the sliding and input window with  maximum compression ratio, and also the values of it. </p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>string) </code> <p>Path where the file is located. </p> required <code>analisisDict</code> <code>dictionary</code> <p>the values obtained in the analisis.</p> required Source code in <code>src/main.py</code> <pre><code>def plotCompressionRatio(file_name, analisisDict):\n    '''\n    Method to plot the compression ratio and print on the screen the sliding and input window with \n    maximum compression ratio, and also the values of it. \n\n    Args:\n        file_name (string) : Path where the file is located. \n        analisisDict (dictionary): the values obtained in the analisis. \n    '''\n\n    keys, _, _, _, compressionFactors, _, _ = convertDictIntoLists(analisisDict)\n\n    maximum_value_key, maximum_value = max(analisisDict.items(), key=lambda item: item[1]['Compression Ratio'])\n    print(\"Mdes and Ment of maximum compression ratio:\", maximum_value_key)\n    print(\"Values from the compression:\\n - Time: \", maximum_value['Time'], \"\\n - Compression Ratio: \", maximum_value['Compression Ratio'],\n          \"\\n - Compression Factor: \", maximum_value['Factor'], \"\\n - Text Length: \", maximum_value['Text length'],\n          \"\\n - Compressed Data Length: \", maximum_value['Compressed data length'])\n\n    fig, ax = plt.subplots()                                                                                # Creation of the bar graph. \n    x_pos = range(len(compressionFactors))                                                                  # Creation of a position range for the bars.\n\n    ax.bar(x_pos, compressionFactors)                                                                       # Draw the bars. \n\n    ax.set_xlabel('Mdes and Ment')                                                                          # Set the label of the x axis. \n    ax.set_ylabel('Compression factor')                                                                     # Set the label of the y axis\n    ax.set_title('Compression factor for ' + file_name)                                                     # Set the title of the figure. \n\n    ax.set_xticks(x_pos)                                                                                    # Set the position of the labels of the values.\n    ax.set_xticklabels(keys, rotation=75)                                                                   # Establish the labels for the values of the axis x,  with a rotation of 75 degrees.\n\n    plt.show()                                                                                              # Show the plot. \n</code></pre>"},{"location":"main/#src.main.plotLength","title":"<code>plotLength(analisisDict)</code>","text":"<p>Method to plot length of the original and the compressed data. </p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>string) </code> <p>Path where the file is located. </p> required <code>analisisDict</code> <code>dictionary</code> <p>the values obtained in the analisis.</p> required Source code in <code>src/main.py</code> <pre><code>def plotLength(analisisDict):\n    '''\n    Method to plot length of the original and the compressed data. \n\n    Args:\n        file_name (string) : Path where the file is located. \n        analisisDict (dictionary): the values obtained in the analisis. \n    '''\n\n    keys, _, _, _, _, originalLength, compressedLength = convertDictIntoLists(analisisDict)                 # Get the lists.\n\n    ancho_barra = 0.35                                                                                      # Width of the bars.\n    posiciones = range(len(keys))                                                                           # Position of the axis x for the bars.\n\n    fig, ax = plt.subplots()                                                                                # Create the figure and the axis.\n    rects1 = ax.bar(posiciones, originalLength, ancho_barra, label='Longitud de Datos Originales')          # Create the bar for the original data.\n\n    rects2 = ax.bar([pos + ancho_barra for pos in posiciones], compressedLength, ancho_barra, label='Longitud de Datos Comprimidos')    # Create the bar for the compressed data.\n\n    ax.set_ylabel('Longitud')                                                                               # Set the label of the axis y. \n    ax.set_title('Data Comparison Original vs. Compress')                                                   # Set the title of the graph.\n    ax.set_xticks([pos + ancho_barra / 2 for pos in posiciones])                                            # Set the position of the labels of the values.\n    ax.set_xticklabels(keys, rotation = 75)                                                                 # Establish the labels for the values of the axis x, with a rotation of 75 degrees. \n    ax.legend()                                                                                             # Set the legend\n\n    plt.show()                                                                                              # Show the plot. \n</code></pre>"},{"location":"main/#src.main.plotTimeAndCompression","title":"<code>plotTimeAndCompression(file_name, analisisDict)</code>","text":"<p>Method to plot the time and compression ratio against the sliding and input window. </p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>string) </code> <p>Path where the file is located. </p> required <code>analisisDict</code> <code>dictionary</code> <p>the values obtained in the analisis.</p> required Source code in <code>src/main.py</code> <pre><code>def plotTimeAndCompression(file_name, analisisDict):\n    '''\n    Method to plot the time and compression ratio against the sliding and input window. \n\n    Args:\n        file_name (string) : Path where the file is located. \n        analisisDict (dictionary): the values obtained in the analisis. \n    '''\n\n    _, mdes_values, ment_values, times, compressionFactors, _, _ = convertDictIntoLists(analisisDict)       # Get the lists.\n\n    fig1 = plt.figure()                                                                                     # Creation of the plot for the time.\n    ax1 = fig1.add_subplot(111, projection='3d')                                                            # Add a 3d subplot. \n    ax1.scatter(mdes_values, ment_values, times, c='r', marker='o')                                         # Create the scatter plot.\n    ax1.set_xlabel('Mdes')                                                                                  # Set x label.\n    ax1.set_ylabel('Ment')                                                                                  # Set the y label.\n    ax1.set_zlabel('Time (s)')                                                                              # Set the z label. \n    ax1.set_title('Time for different values of Mdes and Ment on the file: ' + file_name)                   # Set the title of the plot.\n\n    fig2 = plt.figure()                                                                                     # Creation of the plot for the compression factor.\n    ax2 = fig2.add_subplot(111, projection='3d')                                                            # Add a 3d subplot. \n    ax2.scatter(mdes_values, ment_values, compressionFactors, c='b', marker='x')                            # Create the scatter plot.\n    ax2.set_xlabel('Mdes')                                                                                  # Set x label.\n    ax2.set_ylabel('Ment')                                                                                  # Set the y label.\n    ax2.set_zlabel('Compression factor')                                                                    # Set the z label. \n    ax2.set_title('Compression factor for different values of Mdes and Ment on the file: ' + file_name)     # Set the title of the plot.\n\n    plt.show()                                                                                              # Show the plots\n</code></pre>"},{"location":"main/#src.main.secondExample","title":"<code>secondExample()</code>","text":"<p>Method to show the second example, with a random input data, and then we call the method to compress and decompress.  We have the slinding and input window set as:     - Ment = 4     - Mdes = 8</p> Source code in <code>src/main.py</code> <pre><code>def secondExample():\n    '''\n    Method to show the second example, with a random input data, and then we call the method to compress and decompress. \n    We have the slinding and input window set as:\n        - Ment = 4\n        - Mdes = 8\n    '''\n\n    print(\"SECOND EXAMPLE, with random data\")\n    random_data = ''.join([str(random.randint(0, 1)) for _ in range(250)])                                  # Establish the value of the random data, randomly. \n\n    compressed_data = lz77.lz77_compress(random_data, 4, 8)                                                 # Compress the established data\n    decompressed_data = lz77.lz77_decompress(compressed_data, 4, 8)                                         # Decompress the data previously compressed.\n\n    assert random_data == decompressed_data                                                                 # Check if the initial random data is equal to the decompressed data.\n    print(\"Original data:\", random_data)                                                                    # Show the original data.\n    print(\"Compressed data:\", compressed_data)                                                              # Show the data compressed\n    print(\"Decompressed data:\", decompressed_data)                                                          # Show the decompressed data.\n    print(\"The original data and the decompressed data are equal:\", random_data == decompressed_data, \"\\n\") # Show if the compressed data and the original data are equal.\n</code></pre>"}]}